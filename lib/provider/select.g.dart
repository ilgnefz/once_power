// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'select.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

@ProviderFor(CurrentMode)
const currentModeProvider = CurrentModeProvider._();

final class CurrentModeProvider
    extends $NotifierProvider<CurrentMode, FunctionMode> {
  const CurrentModeProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'currentModeProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$currentModeHash();

  @$internal
  @override
  CurrentMode create() => CurrentMode();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(FunctionMode value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<FunctionMode>(value),
    );
  }
}

String _$currentModeHash() => r'b34f5ae2ee5f4a9ebda79e16b0be3e6d42dc2092';

abstract class _$CurrentMode extends $Notifier<FunctionMode> {
  FunctionMode build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<FunctionMode, FunctionMode>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<FunctionMode, FunctionMode>,
              FunctionMode,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

@ProviderFor(SelectedReplaceType)
const selectedReplaceTypeProvider = SelectedReplaceTypeProvider._();

final class SelectedReplaceTypeProvider
    extends $NotifierProvider<SelectedReplaceType, List<ReplaceType>> {
  const SelectedReplaceTypeProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'selectedReplaceTypeProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$selectedReplaceTypeHash();

  @$internal
  @override
  SelectedReplaceType create() => SelectedReplaceType();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(List<ReplaceType> value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<List<ReplaceType>>(value),
    );
  }
}

String _$selectedReplaceTypeHash() =>
    r'4fb71971a36d1e4a14ed988dee99414f35c6c925';

abstract class _$SelectedReplaceType extends $Notifier<List<ReplaceType>> {
  List<ReplaceType> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<List<ReplaceType>, List<ReplaceType>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<List<ReplaceType>, List<ReplaceType>>,
              List<ReplaceType>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

@ProviderFor(SelectedReserveType)
const selectedReserveTypeProvider = SelectedReserveTypeProvider._();

final class SelectedReserveTypeProvider
    extends $NotifierProvider<SelectedReserveType, List<ReserveType>> {
  const SelectedReserveTypeProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'selectedReserveTypeProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$selectedReserveTypeHash();

  @$internal
  @override
  SelectedReserveType create() => SelectedReserveType();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(List<ReserveType> value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<List<ReserveType>>(value),
    );
  }
}

String _$selectedReserveTypeHash() =>
    r'cdb7522a98c8d080dde495a0d46f33b403b0a522';

abstract class _$SelectedReserveType extends $Notifier<List<ReserveType>> {
  List<ReserveType> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<List<ReserveType>, List<ReserveType>>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<List<ReserveType>, List<ReserveType>>,
              List<ReserveType>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

@ProviderFor(CurrentDateType)
const currentDateTypeProvider = CurrentDateTypeProvider._();

final class CurrentDateTypeProvider
    extends $NotifierProvider<CurrentDateType, DateType> {
  const CurrentDateTypeProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'currentDateTypeProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$currentDateTypeHash();

  @$internal
  @override
  CurrentDateType create() => CurrentDateType();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(DateType value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<DateType>(value),
    );
  }
}

String _$currentDateTypeHash() => r'd734afbdd1b6a221f5888235dc506720daabbd81';

abstract class _$CurrentDateType extends $Notifier<DateType> {
  DateType build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<DateType, DateType>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<DateType, DateType>,
              DateType,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

@ProviderFor(CurrentSort)
const currentSortProvider = CurrentSortProvider._();

final class CurrentSortProvider
    extends $NotifierProvider<CurrentSort, SortType> {
  const CurrentSortProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'currentSortProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$currentSortHash();

  @$internal
  @override
  CurrentSort create() => CurrentSort();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(SortType value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<SortType>(value),
    );
  }
}

String _$currentSortHash() => r'feb21384738aefca713c6326859c37a441629526';

abstract class _$CurrentSort extends $Notifier<SortType> {
  SortType build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<SortType, SortType>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<SortType, SortType>,
              SortType,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

@ProviderFor(CurrentTheme)
const currentThemeProvider = CurrentThemeProvider._();

final class CurrentThemeProvider
    extends $NotifierProvider<CurrentTheme, ThemeType> {
  const CurrentThemeProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'currentThemeProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$currentThemeHash();

  @$internal
  @override
  CurrentTheme create() => CurrentTheme();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(ThemeType value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<ThemeType>(value),
    );
  }
}

String _$currentThemeHash() => r'5438070c83f89fae4291d9d062538e764faeec63';

abstract class _$CurrentTheme extends $Notifier<ThemeType> {
  ThemeType build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<ThemeType, ThemeType>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<ThemeType, ThemeType>,
              ThemeType,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
